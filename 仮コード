----------------------------password_entry.dart----------------------------

import 'package:flutter/foundation.dart';

@immutable
class PasswordEntry {
  final String id;
  final String serviceName;
  final String username;
  final String password;
  final DateTime createdAt;

  const PasswordEntry({
    required this.id,
    required this.serviceName,
    required this.username,
    required this.password,
    required this.createdAt,
  });

  PasswordEntry copyWith({
    String? id,
    String? serviceName,
    String? username,
    String? password,
    DateTime? createdAt,
  }) {
    return PasswordEntry(
      id: id ?? this.id,
      serviceName: serviceName ?? this.serviceName,
      username: username ?? this.username,
      password: password ?? this.password,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  String toString() {
    return 'PasswordEntry(serviceName: $serviceName, username: $username)';
  }
}


----------------------------password_provider.dart----------------------------

// lib/providers/password_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/password_entry.dart';

// StateNotifier: List<PasswordEntry>の状態を管理する
class PasswordListNotifier extends StateNotifier<List<PasswordEntry>> {
  PasswordListNotifier() : super([]); 

  void addEntry(PasswordEntry entry) {
    state = [...state, entry]; 
  }
  
  void updateEntry(PasswordEntry updatedEntry) {
    state = [
      for (final entry in state)
        if (entry.id == updatedEntry.id)
          updatedEntry
        else
          entry,
    ];
  }
  
  void deleteEntry(String id) {
    state = state.where((entry) => entry.id != id).toList();
  }
  
}

final passwordListProvider = 
    StateNotifierProvider<PasswordListNotifier, List<PasswordEntry>>((ref) {
  return PasswordListNotifier();
});


----------------------------edit_screen.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/password_provider.dart';
import '../models/password_entry.dart';
import '../services/generator.dart';

class EditScreen extends ConsumerStatefulWidget {
  final PasswordEntry? entryToEdit;

  const EditScreen({super.key, this.entryToEdit});

  @override
  ConsumerState<EditScreen> createState() => _EditScreenState();
}

class _EditScreenState extends ConsumerState<EditScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _serviceController;
  late TextEditingController _userController;
  late TextEditingController _passwordController;

  @override
  void initState() {
    super.initState();
    _serviceController = TextEditingController(text: widget.entryToEdit?.serviceName ?? '');
    _userController = TextEditingController(text: widget.entryToEdit?.username ?? '');
    _passwordController = TextEditingController(text: widget.entryToEdit?.password ?? '');
  }

  @override
  void dispose() {
    _serviceController.dispose();
    _userController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _saveEntry() {
    if (_formKey.currentState!.validate()) {
      final notifier = ref.read(passwordListProvider.notifier);
      final now = DateTime.now();

      if (widget.entryToEdit == null) {
        final newEntry = PasswordEntry(
          id: PasswordGenerator.generateUniqueId(),
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          createdAt: now,
        );
        notifier.addEntry(newEntry);
      } else {
        final updatedEntry = widget.entryToEdit!.copyWith(
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
        );
        notifier.updateEntry(updatedEntry);
      }
      
      Navigator.of(context).pop();
    }
  }

  void _deleteEntry() {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('削除の確認'),
        content: const Text('本当にこのエントリを削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('キャンセル'),
          ),
          TextButton(
            onPressed: () {
              if (widget.entryToEdit != null) {
                ref.read(passwordListProvider.notifier).deleteEntry(
                  widget.entryToEdit!.id,
                );
              }
              Navigator.of(ctx).pop(); 
              Navigator.of(context).pop(); 
            },
            child: const Text('削除', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.entryToEdit != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(isEditing ? 'パスワード編集' : '新規パスワード作成'),
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              TextFormField(
                controller: _serviceController,
                decoration: const InputDecoration(labelText: 'サービス/ウェブサイト名'),
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              TextFormField(
                controller: _userController,
                decoration: const InputDecoration(labelText: 'ユーザー名/メールアドレス'),
              ),
              TextFormField(
                controller: _passwordController,
                decoration: const InputDecoration(labelText: 'パスワード'),
                obscureText: true,
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              const SizedBox(height: 20),
              
              ElevatedButton(
                onPressed: _saveEntry,
                child: Text(isEditing ? '更新' : '保存'),
              ),
              
              if (isEditing) 
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    onPressed: _deleteEntry,
                    icon: const Icon(Icons.delete),
                    label: const Text('このパスワードを削除'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.red, 
                      foregroundColor: Colors.white,
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}


----------------------------generate_screen.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/password_provider.dart';
import '../models/password_entry.dart';
import '../services/generator.dart';

class EditScreen extends ConsumerStatefulWidget {
  final PasswordEntry? entryToEdit;

  const EditScreen({super.key, this.entryToEdit});

  @override
  ConsumerState<EditScreen> createState() => _EditScreenState();
}

class _EditScreenState extends ConsumerState<EditScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _serviceController;
  late TextEditingController _userController;
  late TextEditingController _passwordController;

  @override
  void initState() {
    super.initState();
    _serviceController = TextEditingController(text: widget.entryToEdit?.serviceName ?? '');
    _userController = TextEditingController(text: widget.entryToEdit?.username ?? '');
    _passwordController = TextEditingController(text: widget.entryToEdit?.password ?? '');
  }

  @override
  void dispose() {
    _serviceController.dispose();
    _userController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _saveEntry() {
    if (_formKey.currentState!.validate()) {
      final notifier = ref.read(passwordListProvider.notifier);
      final now = DateTime.now();

      if (widget.entryToEdit == null) {
        final newEntry = PasswordEntry(
          id: PasswordGenerator.generateUniqueId(),
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          createdAt: now,
        );
        notifier.addEntry(newEntry);
      } else {
        final updatedEntry = widget.entryToEdit!.copyWith(
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
        );
        notifier.updateEntry(updatedEntry);
      }
      
      Navigator.of(context).pop();
    }
  }

  void _deleteEntry() {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('削除の確認'),
        content: const Text('本当にこのエントリを削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('キャンセル'),
          ),
          TextButton(
            onPressed: () {
              if (widget.entryToEdit != null) {
                ref.read(passwordListProvider.notifier).deleteEntry(
                  widget.entryToEdit!.id,
                );
              }
              Navigator.of(ctx).pop(); 
              Navigator.of(context).pop(); 
            },
            child: const Text('削除', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.entryToEdit != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(isEditing ? 'パスワード編集' : '新規パスワード作成'),
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              TextFormField(
                controller: _serviceController,
                decoration: const InputDecoration(labelText: 'サービス/ウェブサイト名'),
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              TextFormField(
                controller: _userController,
                decoration: const InputDecoration(labelText: 'ユーザー名/メールアドレス'),
              ),
              TextFormField(
                controller: _passwordController,
                decoration: const InputDecoration(labelText: 'パスワード'),
                obscureText: true,
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              const SizedBox(height: 20),
              
              // 1. 保存/更新ボタン
              ElevatedButton(
                onPressed: _saveEntry,
                child: Text(isEditing ? '更新' : '保存'),
              ),
              
              if (isEditing) 
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    onPressed: _deleteEntry,
                    icon: const Icon(Icons.delete),
                    label: const Text('このパスワードを削除'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.red, 
                      foregroundColor: Colors.white,
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}


----------------------------generator.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/password_provider.dart';
import '../models/password_entry.dart';
import '../services/generator.dart';

class EditScreen extends ConsumerStatefulWidget {
  final PasswordEntry? entryToEdit;

  const EditScreen({super.key, this.entryToEdit});

  @override
  ConsumerState<EditScreen> createState() => _EditScreenState();
}

class _EditScreenState extends ConsumerState<EditScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _serviceController;
  late TextEditingController _userController;
  late TextEditingController _passwordController;

  @override
  void initState() {
    super.initState();
    _serviceController = TextEditingController(text: widget.entryToEdit?.serviceName ?? '');
    _userController = TextEditingController(text: widget.entryToEdit?.username ?? '');
    _passwordController = TextEditingController(text: widget.entryToEdit?.password ?? '');
  }

  @override
  void dispose() {
    _serviceController.dispose();
    _userController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _saveEntry() {
    if (_formKey.currentState!.validate()) {
      final notifier = ref.read(passwordListProvider.notifier);
      final now = DateTime.now();

      if (widget.entryToEdit == null) {
        final newEntry = PasswordEntry(
          id: PasswordGenerator.generateUniqueId(),
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          createdAt: now,
        );
        notifier.addEntry(newEntry);
      } else {
        final updatedEntry = widget.entryToEdit!.copyWith(
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
        );
        notifier.updateEntry(updatedEntry);
      }
      
      Navigator.of(context).pop();
    }
  }

  void _deleteEntry() {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('削除の確認'),
        content: const Text('本当にこのエントリを削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('キャンセル'),
          ),
          TextButton(
            onPressed: () {
              if (widget.entryToEdit != null) {
                ref.read(passwordListProvider.notifier).deleteEntry(
                  widget.entryToEdit!.id,
                );
              }
              Navigator.of(ctx).pop(); 
              Navigator.of(context).pop(); 
            },
            child: const Text('削除', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.entryToEdit != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(isEditing ? 'パスワード編集' : '新規パスワード作成'),
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              TextFormField(
                controller: _serviceController,
                decoration: const InputDecoration(labelText: 'サービス/ウェブサイト名'),
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              TextFormField(
                controller: _userController,
                decoration: const InputDecoration(labelText: 'ユーザー名/メールアドレス'),
              ),
              TextFormField(
                controller: _passwordController,
                decoration: const InputDecoration(labelText: 'パスワード'),
                obscureText: true,
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              const SizedBox(height: 20),
              
              ElevatedButton(
                onPressed: _saveEntry,
                child: Text(isEditing ? '更新' : '保存'),
              ),
              
              if (isEditing) 
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    onPressed: _deleteEntry,
                    icon: const Icon(Icons.delete),
                    label: const Text('このパスワードを削除'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.red, 
                      foregroundColor: Colors.white,
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}


----------------------------main.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_application1/screens/generate_screen.dart';

void main() {
  runApp(const ProviderScope(
    child: MyApp(),
  ));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Password Prototype',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        useMaterial3: false,
      ),
      home: const GenerateScreen(), 
    );
  }
}


----------------------------pubspec.yaml----------------------------

name: flutter_application1
description: A new Flutter project for a password manager prototype.
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: '>=3.10.0 <4.0.0' 

dependencies:
  flutter:
    sdk: flutter
  
  flutter_riverpod: ^2.5.1

  uuid: ^4.4.0 # ★新たに追加が必要な依存関係

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0 

flutter:
  uses-material-design: true
