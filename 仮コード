----------------------------models\password_entry.dart----------------------------

// ファイルパス: lib/models/password_entry.dart
// 役割: パスワードエントリのデータ構造を定義

class PasswordEntry {
  final String id;
  final String serviceName;
  final String username;
  final String encryptedPassword;
  final DateTime createdAt;
  final DateTime? updatedAt;

  PasswordEntry({
    required this.id,
    required this.serviceName,
    required this.username,
    required this.encryptedPassword,
    required this.createdAt,
    this.updatedAt,
  });

  PasswordEntry copyWith({
    String? serviceName,
    String? username,
    String? encryptedPassword,
    DateTime? updatedAt,
  }) {
    return PasswordEntry(
      id: id,
      serviceName: serviceName ?? this.serviceName,
      username: username ?? this.username,
      encryptedPassword: encryptedPassword ?? this.encryptedPassword,
      createdAt: createdAt,
      updatedAt: updatedAt ?? DateTime.now(),
    );
  }

  @override
  String toString() {
    return 'PasswordEntry(service: $serviceName, user: $username, encrypted: $encryptedPassword)';
  }
}

----------------------------providers\auth_provider.dart----------------------------

// ファイルパス: lib/providers/auth_provider.dart
// 役割: アプリケーション全体の認証状態（ロック/ロック解除）を管理する

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'master_pin_provider.dart';

class AuthNotifier extends StateNotifier<bool> {
	AuthNotifier() : super(false); 

	void authenticate() {
		state = true;
	}

	void lockApp() {
		state = false;
	}
}

final authProvider = StateNotifierProvider<AuthNotifier, bool>(
	(ref) => AuthNotifier(),
);

final isSetupCompleteProvider = Provider<bool>((ref) {
	return ref.watch(masterPinProvider).isPinSet;
});

----------------------------providers\master_pin_provider.dart----------------------------

// ファイルパス: lib/providers/master_pin_provider.dart
// 役割: マスターPINの保存、認証ロジック、生体認証処理を管理する

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:local_auth/local_auth.dart';
import 'package:flutter/foundation.dart';
import 'auth_provider.dart';

class MasterPinState {
	final bool isPinSet;

	MasterPinState({required this.isPinSet});
}

final initialMasterPinState = MasterPinState(isPinSet: false);

class MasterPinNotifier extends StateNotifier<MasterPinState> {
	final Ref _ref; 
	final LocalAuthentication _localAuth = LocalAuthentication();
	static const _pinKey = 'masterPin';

	MasterPinNotifier(this._ref) : super(initialMasterPinState) {
		_loadPinStatus();
	}
	
	Future<void> _loadPinStatus() async {
		final prefs = await SharedPreferences.getInstance();
		final pin = prefs.getString(_pinKey);
		state = MasterPinState(isPinSet: pin != null && pin.isNotEmpty);
        if (state.isPinSet) {
             _ref.read(authProvider.notifier).lockApp();
        }
	}

	Future<void> setPin(String pin) async {
		final prefs = await SharedPreferences.getInstance();
		await prefs.setString(_pinKey, pin);
		state = MasterPinState(isPinSet: true);
		_ref.read(authProvider.notifier).authenticate(); 
	}
    
    Future<bool> checkCurrentPin(String pin) async {
        final prefs = await SharedPreferences.getInstance();
        final savedPin = prefs.getString(_pinKey);
        return savedPin == pin;
    }

	Future<bool> authenticate(String pin) async {
		final prefs = await SharedPreferences.getInstance();
		final savedPin = prefs.getString(_pinKey);

		if (savedPin == pin) {
			_ref.read(authProvider.notifier).authenticate(); 
			return true;
		}
		return false;
	}

	Future<bool> canAuthenticate() async {
		final canCheckBiometrics = await _localAuth.canCheckBiometrics;
		return canCheckBiometrics && await _localAuth.isDeviceSupported();
	}

	Future<bool> authenticateWithBiometrics() async {
		try {
			final authenticated = await _localAuth.authenticate(
				localizedReason: 'アプリをロック解除するために指紋または顔認証を行ってください',
				options: const AuthenticationOptions(
					stickyAuth: true,
					biometricOnly: true,
				),
			);
			
			if (authenticated) {
				_ref.read(authProvider.notifier).authenticate(); 
			}
			return authenticated;
		} catch (e) {
			debugPrint('生体認証エラー: $e');
			return false;
		}
	}
}

final masterPinProvider = StateNotifierProvider<MasterPinNotifier, MasterPinState>(
	(ref) {
		return MasterPinNotifier(ref);
	},
);

----------------------------providers\password_provider.dart----------------------------

// ファイルパス: lib/providers/password_provider.dart
// 役割: パスワードエントリのデータモデルと、エントリリストを管理するRiverpod Provider
// データはメモリ内にのみ保持されます (アプリ終了で消えます)

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

const uuid = Uuid();

class PasswordEntry {
  final String id;
  final String title;
  final String username;
  final String password;
  final String url;
  final DateTime createdAt;

  PasswordEntry({
    required this.id,
    required this.title,
    required this.username,
    required this.password,
    this.url = '',
    required this.createdAt,
  });

  PasswordEntry copyWith({
    String? id,
    String? title,
    String? username,
    String? password,
    String? url,
    DateTime? createdAt,
  }) {
    return PasswordEntry(
      id: id ?? this.id,
      title: title ?? this.title,
      username: username ?? this.username,
      password: password ?? this.password,
      url: url ?? this.url,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}

class PasswordListNotifier extends StateNotifier<List<PasswordEntry>> {
  PasswordListNotifier() : super([
    PasswordEntry(
      id: uuid.v4(),
      title: 'Google アカウント',
      username: 'user@gmail.com',
      password: 'password123',
      url: 'https://www.google.com',
      createdAt: DateTime.now().subtract(const Duration(days: 5)),
    ),
    PasswordEntry(
      id: uuid.v4(),
      title: 'GitHub',
      username: 'dev_user',
      password: 'secure_pass_hash',
      url: 'https://github.com',
      createdAt: DateTime.now().subtract(const Duration(days: 2)),
    ),
  ]);

  void addPassword(PasswordEntry entry) {
    state = [...state, entry];
  }

  void updatePassword(PasswordEntry updatedEntry) {
    state = [
      for (final entry in state)
        if (entry.id == updatedEntry.id) updatedEntry else entry,
    ];
  }

  void deletePassword(String id) {
    state = state.where((entry) => entry.id != id).toList();
  }
}

final passwordListProvider = 
    StateNotifierProvider<PasswordListNotifier, List<PasswordEntry>>((ref) {
  return PasswordListNotifier();
});

----------------------------screens\add_password_screen.dart----------------------------

// ファイルパス: lib/screens/add_password_screen.dart
// 役割: 新しいパスワード情報を入力し、保存するための画面

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import '../providers/password_provider.dart'; 

const uuid = Uuid();

class AddPasswordScreen extends ConsumerWidget {
  const AddPasswordScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final serviceController = TextEditingController();
    final usernameController = TextEditingController();
    final passwordController = TextEditingController();
    final urlController = TextEditingController(); 

    final formKey = GlobalKey<FormState>();

    void saveNewEntry() {
      if (formKey.currentState!.validate()) {
        final newEntry = PasswordEntry(
          id: uuid.v4(),
          title: serviceController.text, 
          username: usernameController.text, 
          password: passwordController.text, 
          url: urlController.text,
          createdAt: DateTime.now(),
        );

        ref.read(passwordListProvider.notifier).addPassword(newEntry);

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('${newEntry.title} をリストに追加しました。')),
        );
        Navigator.of(context).pop();
      }
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('新しいパスワードを追加'),
        backgroundColor: Theme.of(context).colorScheme.primary,
        foregroundColor: Colors.white,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(20.0),
        child: Form(
          key: formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildTextField(
                controller: serviceController, 
                label: 'サービス名 / ウェブサイト (必須)', 
                icon: Icons.title,
                validator: (value) => value!.isEmpty ? 'タイトルは必須です' : null,
              ),
              const SizedBox(height: 20),

              _buildTextField(
                controller: usernameController, 
                label: 'ユーザー名 / メールアドレス', 
                icon: Icons.person,
              ),
              const SizedBox(height: 20),

              _buildPasswordField(
                controller: passwordController,
                validator: (value) => value!.isEmpty ? 'パスワードは必須です' : null,
              ),
              const SizedBox(height: 20),

              _buildTextField(
                controller: urlController, 
                label: 'URL', 
                icon: Icons.link, 
                keyboardType: TextInputType.url,
              ),
              const SizedBox(height: 30),

              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: saveNewEntry,
                  icon: const Icon(Icons.save),
                  label: const Text('保存', style: TextStyle(fontSize: 18)),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 15),
                    backgroundColor: Theme.of(context).colorScheme.secondary,
                    foregroundColor: Colors.white,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTextField({
    required TextEditingController controller, 
    required String label, 
    required IconData icon, 
    int maxLines = 1,
    TextInputType keyboardType = TextInputType.text,
    String? Function(String?)? validator,
  }) {
    return TextFormField(
      controller: controller,
      maxLines: maxLines,
      keyboardType: keyboardType,
      validator: validator,
      decoration: InputDecoration(
        labelText: label,
        prefixIcon: Icon(icon),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(10),
        ),
        filled: true,
        fillColor: Colors.white,
      ),
    );
  }

  Widget _buildPasswordField({
    required TextEditingController controller,
    String? Function(String?)? validator,
  }) {
    return TextFormField(
      controller: controller,
      obscureText: true,
      validator: validator,
      decoration: InputDecoration(
        labelText: 'パスワード (必須)',
        prefixIcon: const Icon(Icons.vpn_key),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(10),
        ),
        filled: true,
        fillColor: Colors.white,
      ),
    );
  }
}

----------------------------screens\auth_screen.dart----------------------------

// ファイルパス: lib/screens/auth_screen.dart
// 役割: アプリケーションの認証フローを処理（マスターPINの設定・入力・生体認証）

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/master_pin_provider.dart';

class AuthScreen extends ConsumerStatefulWidget {
	const AuthScreen({super.key});

	@override
	ConsumerState<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends ConsumerState<AuthScreen> {
	final _pinController = TextEditingController();
	final _confirmPinController = TextEditingController();
	String _errorMessage = '';
	
	bool _isSettingPinMode = false; 
	bool _isBiometricsAvailable = false; 
	bool _isLoading = false; 

	@override
	void initState() {
		super.initState();
		_checkBiometrics(); 
	}
	
	@override
	void dispose() {
		_pinController.dispose();
		_confirmPinController.dispose();
		super.dispose();
	}

	Future<void> _checkBiometrics() async {
		final available = await ref.read(masterPinProvider.notifier).canAuthenticate();
		if (mounted) {
			setState(() {
				_isBiometricsAvailable = available;
			});
		}
	}

	void _submitSetPin() {
		final pin = _pinController.text;
		final confirmPin = _confirmPinController.text;

		if (pin.length != 4) {
			setState(() => _errorMessage = 'PINは4桁の数字で入力してください。');
			return;
		}

		if (pin != confirmPin) {
			setState(() => _errorMessage = '確認用PINが一致しません。');
			return;
		}
		
		ref.read(masterPinProvider.notifier).setPin(pin);
		
		setState(() {
			_errorMessage = '';
			_isSettingPinMode = false; 
			_pinController.clear(); 
			_confirmPinController.clear();
		});
	}

	Future<void> _submitAuthenticate() async {
		if (_isLoading) return; 
		
		final pin = _pinController.text;

		if (pin.length != 4) {
			setState(() => _errorMessage = 'PINは4桁の数字で入力してください。');
			return;
		}
		
		setState(() {
			_isLoading = true;
			_errorMessage = '';
		});
		
		final isSuccess = await ref.read(masterPinProvider.notifier).authenticate(pin);

		if (mounted) {
			setState(() {
				_isLoading = false;
				
				if (isSuccess) { 
					_pinController.clear();
					_errorMessage = ''; 
				} else {
					_errorMessage = 'PINが間違っています。';
				}
			});
		}
	}

	Future<void> _authenticateWithBiometrics() async {
		setState(() => _errorMessage = '');
		final success = await ref.read(masterPinProvider.notifier).authenticateWithBiometrics();
		
		if (!success) {
			setState(() => _errorMessage = '生体認証に失敗しました。PINを入力してください。');
		} else {
			setState(() => _errorMessage = '');
		}
	}

	@override
	Widget build(BuildContext context) {
		final masterPinState = ref.watch(masterPinProvider);
		final isPinSet = masterPinState.isPinSet;
		
		final currentModeIsSetting = !isPinSet || _isSettingPinMode;
		
		final buttonAction = _isLoading 
			? null 
			: (currentModeIsSetting ? _submitSetPin : _submitAuthenticate);

		final theme = Theme.of(context);
		final title = currentModeIsSetting 
				? '新しいマスターPINを設定' 
				: 'マスターPINを入力してロック解除';
			
		final buttonText = currentModeIsSetting ? 'PINを設定して開始' : 'ロック解除';

		return Scaffold(
			body: Center(
				child: SingleChildScrollView(
					padding: const EdgeInsets.all(32.0),
					child: Column(
						mainAxisAlignment: MainAxisAlignment.center,
						crossAxisAlignment: CrossAxisAlignment.stretch,
						children: <Widget>[
							Icon(Icons.lock_person, size: 80, color: theme.colorScheme.primary),
							const SizedBox(height: 16),

							Text(
								title,
								style: theme.textTheme.headlineMedium?.copyWith(
									fontWeight: FontWeight.bold,
									color: theme.colorScheme.primary,
								),
								textAlign: TextAlign.center,
							),
							const SizedBox(height: 32),
					
							TextField(
								controller: _pinController,
								obscureText: true,
								keyboardType: TextInputType.number,
								maxLength: 4,
								textAlign: TextAlign.center,
								style: const TextStyle(fontSize: 24, letterSpacing: 8),
								decoration: InputDecoration(
									labelText: currentModeIsSetting ? '4桁の新しいPIN' : 'PINコード',
									counterText: '',
									border: const OutlineInputBorder(borderRadius: BorderRadius.all(Radius.circular(12))),
									prefixIcon: const Icon(Icons.vpn_key),
								),
							),
							const SizedBox(height: 16),
							
							if (currentModeIsSetting) ...[ 
								TextField(
									controller: _confirmPinController,
									obscureText: true,
									keyboardType: TextInputType.number,
									maxLength: 4,
									textAlign: TextAlign.center,
									style: const TextStyle(fontSize: 24, letterSpacing: 8),
									decoration: const InputDecoration(
										labelText: '確認用PINコード',
										counterText: '',
										border: OutlineInputBorder(borderRadius: BorderRadius.all(Radius.circular(12))),
										prefixIcon: Icon(Icons.check_circle_outline),
									),
								),
								const SizedBox(height: 32),
							],
							
							currentModeIsSetting ? const SizedBox.shrink() : const SizedBox(height: 16),


							if (_errorMessage.isNotEmpty)
								Padding(
									padding: const EdgeInsets.only(bottom: 16),
									child: Text(
										_errorMessage,
										style: const TextStyle(color: Colors.red, fontWeight: FontWeight.bold),
										textAlign: TextAlign.center,
									),
								),

							ElevatedButton(
								onPressed: buttonAction,
								style: ElevatedButton.styleFrom(
									minimumSize: const Size(double.infinity, 50),
									backgroundColor: theme.colorScheme.primary,
									foregroundColor: theme.colorScheme.onPrimary,
									shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
									elevation: 4,
								),
								child: _isLoading 
									? const SizedBox(
										width: 24,
										height: 24,
										child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3),
									  )
									: Text(buttonText, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
							),

							if (isPinSet && !currentModeIsSetting && _isBiometricsAvailable)
								Padding(
									padding: const EdgeInsets.only(top: 24),
									child: Column(
										children: [
											const Divider(height: 32),
											
											IconButton(
												icon: const Icon(Icons.fingerprint, size: 56),
												onPressed: _isLoading ? null : _authenticateWithBiometrics,
												tooltip: '指紋/顔認証でロック解除',
												color: theme.colorScheme.secondary,
											),
											const SizedBox(height: 8),
											Text('または 生体認証で解除', style: TextStyle(color: theme.colorScheme.secondary)),
										],
									),
								),

							if (isPinSet && !currentModeIsSetting)
								Padding(
									padding: const EdgeInsets.only(top: 24.0),
									child: TextButton(
										onPressed: _isLoading ? null : () {
											setState(() {
												_isSettingPinMode = true;
												_errorMessage = '';
												_pinController.clear();
												_confirmPinController.clear();
											});
										},
										child: const Text('PINを再設定する'),
									),
								),
						],
					),
				),
			),
		);
	}
}

----------------------------screens\edit_screen.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/password_provider.dart';
import '../models/password_entry.dart';
import '../services/generator.dart';

class EditScreen extends ConsumerStatefulWidget {
  final PasswordEntry? entryToEdit;

  const EditScreen({super.key, this.entryToEdit});

  @override
  ConsumerState<EditScreen> createState() => _EditScreenState();
}

class _EditScreenState extends ConsumerState<EditScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _serviceController;
  late TextEditingController _userController;
  late TextEditingController _passwordController;

  @override
  void initState() {
    super.initState();
    _serviceController = TextEditingController(text: widget.entryToEdit?.serviceName ?? '');
    _userController = TextEditingController(text: widget.entryToEdit?.username ?? '');
    _passwordController = TextEditingController(text: widget.entryToEdit?.password ?? '');
  }

  @override
  void dispose() {
    _serviceController.dispose();
    _userController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _saveEntry() {
    if (_formKey.currentState!.validate()) {
      final notifier = ref.read(passwordListProvider.notifier);
      final now = DateTime.now();

      if (widget.entryToEdit == null) {
        final newEntry = PasswordEntry(
          id: PasswordGenerator.generateUniqueId(),
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          createdAt: now,
        );
        notifier.addEntry(newEntry);
      } else {
        final updatedEntry = widget.entryToEdit!.copyWith(
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
        );
        notifier.updateEntry(updatedEntry);
      }
      
      Navigator.of(context).pop();
    }
  }

  void _copyPassword() {
    final password = _passwordController.text;
    if (password.isNotEmpty) {
      Clipboard.setData(ClipboardData(text: password));

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('パスワードをクリップボードにコピーしました')),
      );
    }
  }

  void _deleteEntry() {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('削除の確認'),
        content: const Text('本当にこのエントリを削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('キャンセル'),
          ),
          TextButton(
            onPressed: () {
              if (widget.entryToEdit != null) {
                ref.read(passwordListProvider.notifier).deleteEntry(
                  widget.entryToEdit!.id,
                );
              }
              Navigator.of(ctx).pop(); 
              Navigator.of(context).pop(); 
            },
            child: const Text('削除', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.entryToEdit != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(isEditing ? 'パスワード編集' : '新規パスワード作成'),
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              TextFormField(
                controller: _serviceController,
                decoration: const InputDecoration(labelText: 'サービス/ウェブサイト名'),
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              TextFormField(
                controller: _userController,
                decoration: const InputDecoration(labelText: 'ユーザー名/メールアドレス'),
              ),
              TextFormField(
                controller: _passwordController,
                obscureText: true,
                decoration: InputDecoration(
                  labelText: 'パスワード',
                  suffixIcon: IconButton(
                    icon: const Icon(Icons.copy),
                    onPressed: _copyPassword,
                  ),
                ),
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              const SizedBox(height: 20),
              
              ElevatedButton(
                onPressed: _saveEntry,
                child: Text(isEditing ? '更新' : '保存'),
              ),
              
              if (isEditing) 
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    onPressed: _deleteEntry,
                    icon: const Icon(Icons.delete),
                    label: const Text('このパスワードを削除'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.red, 
                      foregroundColor: Colors.white,
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

----------------------------screens\generate_screen.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/password_provider.dart';
import '../models/password_entry.dart';
import '../services/generator.dart';
import 'edit_screen.dart';

class GenerateScreen extends ConsumerStatefulWidget {
	const GenerateScreen({super.key});

	@override
	ConsumerState<GenerateScreen> createState() => _GenerateScreenState();
}

class _GenerateScreenState extends ConsumerState<GenerateScreen> {
	int _length = 16;
	bool _useUpper = true;
	bool _useNumbers = true;
	bool _useSymbols = true;
	String _generatedPassword = '';

	void _generateAndAddPassword() {
		final generatedPass = PasswordGenerator.generatePassword(
			length: _length,
			useUpper: _useUpper,
			useNumbers: _useNumbers,
			useSymbols: _useSymbols,
		);

		setState(() {
			_generatedPassword = generatedPass;
		});

		if (generatedPass.isNotEmpty && !generatedPass.startsWith('エラー')) {
			final newEntry = PasswordEntry(
				id: PasswordGenerator.generateUniqueId(),
				serviceName: '（未設定）自動生成',
				username: '',
				password: generatedPass,
				createdAt: DateTime.now(),
			);
			
			ref.read(passwordListProvider.notifier).addEntry(newEntry);
		}
	}

	@override
	Widget build(BuildContext context) {
		final passwordList = ref.watch(passwordListProvider);

		return Scaffold(
			appBar: AppBar(title: const Text('パスワード生成と一覧')),
			body: SingleChildScrollView(
				padding: const EdgeInsets.all(16.0),
				child: Column(
					crossAxisAlignment: CrossAxisAlignment.start,
					children: [
						const Text('生成設定', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
						Slider(
							value: _length.toDouble(),
							min: 8, max: 32, divisions: 24,
							label: _length.toString(),
							onChanged: (double value) => setState(() => _length = value.round()),
						),
						Text('長さ: $_length'),
						
						CheckboxListTile(title: const Text('大文字 (A-Z)'), value: _useUpper, onChanged: (val) => setState(() => _useUpper = val!)),
						CheckboxListTile(title: const Text('数字 (0-9)'), value: _useNumbers, onChanged: (val) => setState(() => _useNumbers = val!)),
						CheckboxListTile(title: const Text('記号 (!@#\$)'), value: _useSymbols, onChanged: (val) => setState(() => _useSymbols = val!)),

						ElevatedButton(
							onPressed: _generateAndAddPassword,
							child: const Text('パスワードを生成 & リストに追加'),
						),
						
						if (_generatedPassword.isNotEmpty) 
							Padding(
								padding: const EdgeInsets.only(top: 16.0),
								child: Text('生成されたパスワード: $_generatedPassword', style: const TextStyle(fontWeight: FontWeight.bold)),
							),
						
						const Divider(height: 32),
						
						const Text('保存済みパスワード', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
						
						ListView.builder(
							shrinkWrap: true,
							physics: const NeverScrollableScrollPhysics(),
							itemCount: passwordList.length,
							itemBuilder: (context, index) {
								final entry = passwordList[index];
								return ListTile(
									title: Text(entry.serviceName),
									subtitle: Text('ユーザー名: ${entry.username.isEmpty ? 'N/A' : entry.username} | パスワード: ******'), // パスワードは非表示
									trailing: IconButton(
										icon: const Icon(Icons.edit),
										onPressed: () {
											Navigator.of(context).push(
												MaterialPageRoute(
													builder: (context) => EditScreen(entryToEdit: entry),
												),
											);
										},
									),
								);
							},
						),
					],
				),
			),
			floatingActionButton: FloatingActionButton(
				onPressed: () {
					Navigator.of(context).push(
						MaterialPageRoute(
							builder: (context) => const EditScreen(entryToEdit: null),
						),
					);
				},
				child: const Icon(Icons.add),
			),
		);
	}
}

----------------------------screens\pin_screen.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/master_pin_provider.dart';

enum PinScreenMode { setup, authenticate }

class PinScreen extends ConsumerStatefulWidget {
  final PinScreenMode mode;

  const PinScreen({super.key, required this.mode});

  @override
  ConsumerState<PinScreen> createState() => _PinScreenState();
}

class _PinScreenState extends ConsumerState<PinScreen> {
  final _pinController = TextEditingController();
  String _message = '';

  @override
  void dispose() {
    _pinController.dispose();
    super.dispose();
  }

  void _processPin() async {
    final pin = _pinController.text;
    final notifier = ref.read(masterPinProvider.notifier);
    
    if (pin.length < 4) {
      setState(() {
        _message = 'PINは4桁以上である必要があります。';
      });
      return;
    }
    
    setState(() {
      _message = '';
    });

    if (widget.mode == PinScreenMode.setup) {
      await notifier.setPin(pin);
      
    } else {
      final success = notifier.authenticate(pin);
      if (!success) {
        setState(() {
          _message = 'PINが一致しません。';
        });
        _pinController.clear();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final title = widget.mode == PinScreenMode.setup ? 'マスターPINの設定' : 'マスターPINの入力';
    final helpText = widget.mode == PinScreenMode.setup 
                  ? '安全のために4桁以上のPINを設定してください。'
                  : 'アプリを続けるにはPINを入力してください。';
    final buttonText = widget.mode == PinScreenMode.setup ? 'PINを設定して開始' : '認証';

    return Scaffold(
      appBar: AppBar(
        title: Text(title),
        automaticallyImplyLeading: false,
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(32.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(helpText, textAlign: TextAlign.center),
              const SizedBox(height: 24),
              SizedBox(
                width: 200, 
                child: TextField(
                  controller: _pinController,
                  keyboardType: TextInputType.number,
                  obscureText: true,
                  textAlign: TextAlign.center,
                  maxLength: 6, 
                  decoration: InputDecoration(
                    labelText: 'PINコード',
                    errorText: _message.isEmpty ? null : _message,
                    border: const OutlineInputBorder(),
                    counterText: '',
                  ),
                  onSubmitted: (_) => _processPin(), 
                ),
              ),
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: _processPin,
                child: Text(buttonText),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

----------------------------services\generator.dart----------------------------

import 'dart:math';
import 'package:uuid/uuid.dart'; 

const uuid = Uuid();

class PasswordGenerator {
  static const _lower = 'abcdefghijklmnopqrstuvwxyz';
  static const _upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  static const _numbers = '0123456789';
  static const _symbols = '!@#\$%^&*()_+=-`~[]{}|;:,.<>?/'; 

  static String generatePassword({
    required int length,
    bool useUpper = true,
    bool useNumbers = true,
    bool useSymbols = true,
  }) {
    String charPool = _lower;
    if (useUpper) charPool += _upper;
    if (useNumbers) charPool += _numbers;
    if (useSymbols) charPool += _symbols;

    if (charPool.isEmpty || length <= 0) {
      return '';
    }

    final random = Random.secure();
    return List.generate(length, (index) {
      final randomIndex = random.nextInt(charPool.length);
      return charPool[randomIndex];
    }).join();
  }

  static String generateUniqueId() {
    return uuid.v4();
  }
}

----------------------------main.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'screens/generate_screen.dart'; 
import 'screens/pin_screen.dart'; 
import 'providers/master_pin_provider.dart'; 

void main() {
  runApp(const ProviderScope(child: MyApp())); 
}

class MyApp extends ConsumerWidget { 
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final pinState = ref.watch(masterPinProvider);
    
    if (pinState.isSetup == false && pinState.isAuthenticated == false) {
      return const MaterialApp(
        debugShowCheckedModeBanner: false,
        home: Scaffold(body: Center(child: CircularProgressIndicator())),
      );
    }

    Widget homeScreen;

    if (pinState.isSetup && !pinState.isAuthenticated) {
      homeScreen = const PinScreen(mode: PinScreenMode.authenticate);
    } else if (!pinState.isSetup) {
      homeScreen = const PinScreen(mode: PinScreenMode.setup);
    } else {
      homeScreen = const GenerateScreen(); 
    }

    return MaterialApp(
      title: 'Password Manager',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      debugShowCheckedModeBanner: false,
      
      home: homeScreen,
    );
  }
}

----------------------------pubspec.yaml----------------------------

name: flutter_application1
description: A new Flutter project for a password manager prototype.
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: '>=3.10.0 <4.0.0' 

dependencies:
  flutter:
    sdk: flutter
  
  flutter_riverpod: ^2.5.1
  shared_preferences: ^2.2.2
  pointycastle: ^3.0.3

  uuid: ^4.4.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0 

flutter:
  uses-material-design: true
