----------------------------password_entry.dart----------------------------

import 'package:flutter/foundation.dart';

@immutable
class PasswordEntry {
  final String id;
  final String serviceName;
  final String username;
  final String password;
  final DateTime createdAt;

  const PasswordEntry({
    required this.id,
    required this.serviceName,
    required this.username,
    required this.password,
    required this.createdAt,
  });

  PasswordEntry copyWith({
    String? id,
    String? serviceName,
    String? username,
    String? password,
    DateTime? createdAt,
  }) {
    return PasswordEntry(
      id: id ?? this.id,
      serviceName: serviceName ?? this.serviceName,
      username: username ?? this.username,
      password: password ?? this.password,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  String toString() {
    return 'PasswordEntry(serviceName: $serviceName, username: $username)';
  }
}


----------------------------password_provider.dart----------------------------

// lib/providers/password_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/password_entry.dart'; // 定義したモデルをインポート

// StateNotifier: List<PasswordEntry>の状態を管理する
class PasswordListNotifier extends StateNotifier<List<PasswordEntry>> {
  // 初期状態を空のリストで設定
  PasswordListNotifier() : super([]); 

  // 【C: Create】 新しいエントリを追加
  void addEntry(PasswordEntry entry) {
    // 状態を新しいリストで置き換える (イミュータブルな操作)
    state = [...state, entry]; 
  }
  
  // 【U: Update】 既存のエントリを更新
  void updateEntry(PasswordEntry updatedEntry) {
    state = [
      for (final entry in state)
        if (entry.id == updatedEntry.id)
          updatedEntry // IDが一致したら新しいエントリに置き換え
        else
          entry, // それ以外はそのまま
    ];
  }
  
  // 【D: Delete】 エントリを削除
  void deleteEntry(String id) {
    // IDが一致しないエントリだけを残す
    state = state.where((entry) => entry.id != id).toList();
  }
  
  // 【R: Read】 状態（state）自体が読み取り操作として機能する
}

// UIからこの状態にアクセスするためのProvider
final passwordListProvider = 
    StateNotifierProvider<PasswordListNotifier, List<PasswordEntry>>((ref) {
  return PasswordListNotifier();
});


----------------------------edit_screen.dart----------------------------

// lib/screens/edit_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/password_provider.dart';
import '../models/password_entry.dart';
import '../services/generator.dart'; // ID生成用

class EditScreen extends ConsumerStatefulWidget {
  final PasswordEntry? entryToEdit; // 編集対象のエントリ（新規作成の場合は null）

  const EditScreen({super.key, this.entryToEdit});

  @override
  ConsumerState<EditScreen> createState() => _EditScreenState();
}

class _EditScreenState extends ConsumerState<EditScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _serviceController;
  late TextEditingController _userController;
  late TextEditingController _passwordController;

  @override
  void initState() {
    super.initState();
    // 既存エントリがあればその値で初期化、なければ空で初期化
    _serviceController = TextEditingController(text: widget.entryToEdit?.serviceName ?? '');
    _userController = TextEditingController(text: widget.entryToEdit?.username ?? '');
    _passwordController = TextEditingController(text: widget.entryToEdit?.password ?? '');
  }

  @override
  void dispose() {
    _serviceController.dispose();
    _userController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _saveEntry() {
    if (_formKey.currentState!.validate()) {
      final notifier = ref.read(passwordListProvider.notifier);
      final now = DateTime.now();

      if (widget.entryToEdit == null) {
        // --- 新規作成 ---
        final newEntry = PasswordEntry(
          id: PasswordGenerator.generateUniqueId(),
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          createdAt: now,
        );
        notifier.addEntry(newEntry); // addEntryメソッドを呼び出し
      } else {
        // --- 編集 ---
        final updatedEntry = widget.entryToEdit!.copyWith(
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          // createdAt は変更しない
        );
        notifier.updateEntry(updatedEntry); // updateEntryメソッドを呼び出し
      }
      
      Navigator.of(context).pop(); // 画面を閉じる
    }
  }

  // ★ 削除機能の追加
  void _deleteEntry() {
    // 削除確認ダイアログの表示
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('削除の確認'),
        content: const Text('本当にこのエントリを削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(), // キャンセル
            child: const Text('キャンセル'),
          ),
          TextButton(
            onPressed: () {
              // ProviderのNotifierにアクセスし、deleteEntryを呼び出す
              if (widget.entryToEdit != null) {
                ref.read(passwordListProvider.notifier).deleteEntry(
                  widget.entryToEdit!.id,
                );
              }
              // ダイアログを閉じる
              Navigator.of(ctx).pop(); 
              // 編集画面を閉じて、一覧画面に戻る
              Navigator.of(context).pop(); 
            },
            child: const Text('削除', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }
  // ★ 削除機能の追加ここまで

  @override
  Widget build(BuildContext context) {
    // 編集モードかどうかを判断
    final isEditing = widget.entryToEdit != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(isEditing ? 'パスワード編集' : '新規パスワード作成'),
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              TextFormField(
                controller: _serviceController,
                decoration: const InputDecoration(labelText: 'サービス/ウェブサイト名'),
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              TextFormField(
                controller: _userController,
                decoration: const InputDecoration(labelText: 'ユーザー名/メールアドレス'),
              ),
              TextFormField(
                controller: _passwordController,
                decoration: const InputDecoration(labelText: 'パスワード'),
                obscureText: true,
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              const SizedBox(height: 20),
              
              // 1. 保存/更新ボタン
              ElevatedButton(
                onPressed: _saveEntry,
                child: Text(isEditing ? '更新' : '保存'),
              ),
              
              // 2. ★ 削除ボタン (編集モードのみ表示)
              if (isEditing) 
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    onPressed: _deleteEntry, // 削除メソッドを呼び出す
                    icon: const Icon(Icons.delete),
                    label: const Text('このパスワードを削除'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.red, 
                      foregroundColor: Colors.white,
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}


----------------------------generate_screen.dart----------------------------

// lib/screens/edit_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/password_provider.dart';
import '../models/password_entry.dart';
import '../services/generator.dart'; // ID生成用

class EditScreen extends ConsumerStatefulWidget {
  final PasswordEntry? entryToEdit; // 編集対象のエントリ（新規作成の場合は null）

  const EditScreen({super.key, this.entryToEdit});

  @override
  ConsumerState<EditScreen> createState() => _EditScreenState();
}

class _EditScreenState extends ConsumerState<EditScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _serviceController;
  late TextEditingController _userController;
  late TextEditingController _passwordController;

  @override
  void initState() {
    super.initState();
    // 既存エントリがあればその値で初期化、なければ空で初期化
    _serviceController = TextEditingController(text: widget.entryToEdit?.serviceName ?? '');
    _userController = TextEditingController(text: widget.entryToEdit?.username ?? '');
    _passwordController = TextEditingController(text: widget.entryToEdit?.password ?? '');
  }

  @override
  void dispose() {
    _serviceController.dispose();
    _userController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _saveEntry() {
    if (_formKey.currentState!.validate()) {
      final notifier = ref.read(passwordListProvider.notifier);
      final now = DateTime.now();

      if (widget.entryToEdit == null) {
        // --- 新規作成 ---
        final newEntry = PasswordEntry(
          id: PasswordGenerator.generateUniqueId(),
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          createdAt: now,
        );
        notifier.addEntry(newEntry); // addEntryメソッドを呼び出し
      } else {
        // --- 編集 ---
        final updatedEntry = widget.entryToEdit!.copyWith(
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          // createdAt は変更しない
        );
        notifier.updateEntry(updatedEntry); // updateEntryメソッドを呼び出し
      }
      
      Navigator.of(context).pop(); // 画面を閉じる
    }
  }

  // ★ 削除機能の追加
  void _deleteEntry() {
    // 削除確認ダイアログの表示
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('削除の確認'),
        content: const Text('本当にこのエントリを削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(), // キャンセル
            child: const Text('キャンセル'),
          ),
          TextButton(
            onPressed: () {
              // ProviderのNotifierにアクセスし、deleteEntryを呼び出す
              if (widget.entryToEdit != null) {
                ref.read(passwordListProvider.notifier).deleteEntry(
                  widget.entryToEdit!.id,
                );
              }
              // ダイアログを閉じる
              Navigator.of(ctx).pop(); 
              // 編集画面を閉じて、一覧画面に戻る
              Navigator.of(context).pop(); 
            },
            child: const Text('削除', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }
  // ★ 削除機能の追加ここまで

  @override
  Widget build(BuildContext context) {
    // 編集モードかどうかを判断
    final isEditing = widget.entryToEdit != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(isEditing ? 'パスワード編集' : '新規パスワード作成'),
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              TextFormField(
                controller: _serviceController,
                decoration: const InputDecoration(labelText: 'サービス/ウェブサイト名'),
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              TextFormField(
                controller: _userController,
                decoration: const InputDecoration(labelText: 'ユーザー名/メールアドレス'),
              ),
              TextFormField(
                controller: _passwordController,
                decoration: const InputDecoration(labelText: 'パスワード'),
                obscureText: true,
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              const SizedBox(height: 20),
              
              // 1. 保存/更新ボタン
              ElevatedButton(
                onPressed: _saveEntry,
                child: Text(isEditing ? '更新' : '保存'),
              ),
              
              // 2. ★ 削除ボタン (編集モードのみ表示)
              if (isEditing) 
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    onPressed: _deleteEntry, // 削除メソッドを呼び出す
                    icon: const Icon(Icons.delete),
                    label: const Text('このパスワードを削除'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.red, 
                      foregroundColor: Colors.white,
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}


----------------------------generator.dart----------------------------

// lib/screens/edit_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/password_provider.dart';
import '../models/password_entry.dart';
import '../services/generator.dart'; // ID生成用

class EditScreen extends ConsumerStatefulWidget {
  final PasswordEntry? entryToEdit; // 編集対象のエントリ（新規作成の場合は null）

  const EditScreen({super.key, this.entryToEdit});

  @override
  ConsumerState<EditScreen> createState() => _EditScreenState();
}

class _EditScreenState extends ConsumerState<EditScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _serviceController;
  late TextEditingController _userController;
  late TextEditingController _passwordController;

  @override
  void initState() {
    super.initState();
    // 既存エントリがあればその値で初期化、なければ空で初期化
    _serviceController = TextEditingController(text: widget.entryToEdit?.serviceName ?? '');
    _userController = TextEditingController(text: widget.entryToEdit?.username ?? '');
    _passwordController = TextEditingController(text: widget.entryToEdit?.password ?? '');
  }

  @override
  void dispose() {
    _serviceController.dispose();
    _userController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _saveEntry() {
    if (_formKey.currentState!.validate()) {
      final notifier = ref.read(passwordListProvider.notifier);
      final now = DateTime.now();

      if (widget.entryToEdit == null) {
        // --- 新規作成 ---
        final newEntry = PasswordEntry(
          id: PasswordGenerator.generateUniqueId(),
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          createdAt: now,
        );
        notifier.addEntry(newEntry); // addEntryメソッドを呼び出し
      } else {
        // --- 編集 ---
        final updatedEntry = widget.entryToEdit!.copyWith(
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          // createdAt は変更しない
        );
        notifier.updateEntry(updatedEntry); // updateEntryメソッドを呼び出し
      }
      
      Navigator.of(context).pop(); // 画面を閉じる
    }
  }

  // ★ 削除機能の追加
  void _deleteEntry() {
    // 削除確認ダイアログの表示
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('削除の確認'),
        content: const Text('本当にこのエントリを削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(), // キャンセル
            child: const Text('キャンセル'),
          ),
          TextButton(
            onPressed: () {
              // ProviderのNotifierにアクセスし、deleteEntryを呼び出す
              if (widget.entryToEdit != null) {
                ref.read(passwordListProvider.notifier).deleteEntry(
                  widget.entryToEdit!.id,
                );
              }
              // ダイアログを閉じる
              Navigator.of(ctx).pop(); 
              // 編集画面を閉じて、一覧画面に戻る
              Navigator.of(context).pop(); 
            },
            child: const Text('削除', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }
  // ★ 削除機能の追加ここまで

  @override
  Widget build(BuildContext context) {
    // 編集モードかどうかを判断
    final isEditing = widget.entryToEdit != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(isEditing ? 'パスワード編集' : '新規パスワード作成'),
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              TextFormField(
                controller: _serviceController,
                decoration: const InputDecoration(labelText: 'サービス/ウェブサイト名'),
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              TextFormField(
                controller: _userController,
                decoration: const InputDecoration(labelText: 'ユーザー名/メールアドレス'),
              ),
              TextFormField(
                controller: _passwordController,
                decoration: const InputDecoration(labelText: 'パスワード'),
                obscureText: true,
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              const SizedBox(height: 20),
              
              // 1. 保存/更新ボタン
              ElevatedButton(
                onPressed: _saveEntry,
                child: Text(isEditing ? '更新' : '保存'),
              ),
              
              // 2. ★ 削除ボタン (編集モードのみ表示)
              if (isEditing) 
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    onPressed: _deleteEntry, // 削除メソッドを呼び出す
                    icon: const Icon(Icons.delete),
                    label: const Text('このパスワードを削除'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.red, 
                      foregroundColor: Colors.white,
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}


----------------------------main.dart----------------------------

// lib/main.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// プロジェクト名が 'flutter_application1' の場合を仮定してインポート
import 'package:flutter_application1/screens/generate_screen.dart';

void main() {
  // アプリ全体をProviderScopeでラップし、Riverpodを有効化
  runApp(const ProviderScope(
    child: MyApp(),
  ));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Password Prototype',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        useMaterial3: false,
      ),
      // メイン画面を設定
      home: const GenerateScreen(), 
    );
  }
}


----------------------------pubspec.yaml----------------------------

# pubspec.yaml

name: flutter_application1 # または flutter_application1 （プロジェクト名に依存）
description: A new Flutter project for a password manager prototype.
publish_to: 'none'

version: 1.0.0+1

environment:
  # ★ dot-shorthands機能のエラー解消のために 3.10.0 以降に更新済みと推測
  sdk: '>=3.10.0 <4.0.0' 

dependencies:
  flutter:
    sdk: flutter
  
  # 状態管理のために必須
  flutter_riverpod: ^2.5.1 # バージョンは最新の安定版に依存

  # パスワード生成ロジック（lib/services/generator.dart）でID生成のために必要
  uuid: ^4.4.0 # ★新たに追加が必要な依存関係

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0 

flutter:
  uses-material-design: true
