----------------------------models\password_entry.dart----------------------------

import 'package:flutter/foundation.dart';

@immutable
class PasswordEntry {
  final String id;
  final String serviceName;
  final String username;
  final String password;
  final DateTime createdAt;

  const PasswordEntry({
    required this.id,
    required this.serviceName,
    required this.username,
    required this.password,
    required this.createdAt,
  });

  PasswordEntry copyWith({
    String? id,
    String? serviceName,
    String? username,
    String? password,
    DateTime? createdAt,
  }) {
    return PasswordEntry(
      id: id ?? this.id,
      serviceName: serviceName ?? this.serviceName,
      username: username ?? this.username,
      password: password ?? this.password,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  String toString() {
    return 'PasswordEntry(serviceName: $serviceName, username: $username)';
  }
}


----------------------------providers\master_pin_provider.dart----------------------------

import 'dart:convert';
import 'dart:typed_data';
import 'dart:math';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:pointycastle/api.dart'; 
import 'package:pointycastle/digests/sha256.dart';
import 'package:pointycastle/key_derivators/api.dart';
import 'package:pointycastle/key_derivators/pbkdf2.dart';
import 'package:pointycastle/macs/hmac.dart';
import 'package:pointycastle/pointycastle.dart' as pc;

const _keyLength = 32;
const _iterations = 10000;
const _saltLength = 16;

class MasterPinState {
  final bool isSetup;
  final bool isAuthenticated;

  MasterPinState({required this.isSetup, this.isAuthenticated = false});

  MasterPinState copyWith({bool? isSetup, bool? isAuthenticated}) {
    return MasterPinState(
      isSetup: isSetup ?? this.isSetup,
      isAuthenticated: isAuthenticated ?? this.isAuthenticated,
    );
  }
}

String _hashPin(String pin) {
  final bytes = Uint8List.fromList(utf8.encode(pin));
  final digest = SHA256Digest().process(bytes);
  return base64Encode(digest);
}

Uint8List _generateSalt() {
  final secureRandom = pc.SecureRandom('Fortuna');
  
  final seed = List<int>.generate(32, (_) => Random.secure().nextInt(256));
  secureRandom.seed(KeyParameter(Uint8List.fromList(seed)));

  return secureRandom.nextBytes(_saltLength);
}

Uint8List _deriveKey(String pin, Uint8List salt) {
  final saltParams = Pbkdf2Parameters(salt, _iterations, _keyLength);
  final pbkdf2 = PBKDF2KeyDerivator(HMac(SHA256Digest(), 64))
    ..init(saltParams);

  final pinBytes = Uint8List.fromList(utf8.encode(pin));
  return pbkdf2.process(pinBytes);
}

class MasterPinNotifier extends StateNotifier<MasterPinState> {
  static const _hashKey = 'master_pin_hash';
  static const _saltKey = 'master_pin_salt';
  late final SharedPreferences _prefs;

  MasterPinNotifier() : super(MasterPinState(isSetup: false)) {
    _loadPinStatus();
  }

  Future<void> _loadPinStatus() async {
    _prefs = await SharedPreferences.getInstance();
    final pinHash = _prefs.getString(_hashKey);
    final isPinSet = pinHash != null && pinHash.isNotEmpty;
    
    state = state.copyWith(isSetup: isPinSet);
    
    if (!isPinSet) {
      state = state.copyWith(isAuthenticated: true);
    }
  }

  Future<bool> setPin(String pin) async {
    if (pin.length < 4) return false;
    
    final hashedPin = _hashPin(pin);
    await _prefs.setString(_hashKey, hashedPin);
    
    final salt = _generateSalt();
    await _prefs.setString(_saltKey, base64Encode(salt)); 
    
    state = state.copyWith(isSetup: true, isAuthenticated: true);
    return true;
  }

  bool authenticate(String pin) {
    final savedHashedPin = _prefs.getString(_hashKey);
    final inputHashedPin = _hashPin(pin);
    
    final success = savedHashedPin == inputHashedPin;
    if (success) {
      state = state.copyWith(isAuthenticated: true);
    }
    return success;
  }

  Future<Uint8List?> getEncryptionKey(String pin) async {
    final saltBase64 = _prefs.getString(_saltKey);
    
    if (saltBase64 == null) return null; 
    
    final salt = base64Decode(saltBase64);
    
    return _deriveKey(pin, salt);
  }
}

final masterPinProvider = StateNotifierProvider<MasterPinNotifier, MasterPinState>(
  (ref) => MasterPinNotifier(),
);

----------------------------providers\password_provider.dart----------------------------

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/password_entry.dart';

class PasswordListNotifier extends StateNotifier<List<PasswordEntry>> {
  PasswordListNotifier() : super([]); 

  void addEntry(PasswordEntry entry) {
    state = [...state, entry]; 
  }
  
  void updateEntry(PasswordEntry updatedEntry) {
    state = [
      for (final entry in state)
        if (entry.id == updatedEntry.id)
          updatedEntry
        else
          entry,
    ];
  }
  
  void deleteEntry(String id) {
    state = state.where((entry) => entry.id != id).toList();
  }
  
}

final passwordListProvider = 
    StateNotifierProvider<PasswordListNotifier, List<PasswordEntry>>((ref) {
  return PasswordListNotifier();
});

----------------------------screens\edit_screen.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/password_provider.dart';
import '../models/password_entry.dart';
import '../services/generator.dart';

class EditScreen extends ConsumerStatefulWidget {
  final PasswordEntry? entryToEdit;

  const EditScreen({super.key, this.entryToEdit});

  @override
  ConsumerState<EditScreen> createState() => _EditScreenState();
}

class _EditScreenState extends ConsumerState<EditScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _serviceController;
  late TextEditingController _userController;
  late TextEditingController _passwordController;

  @override
  void initState() {
    super.initState();
    _serviceController = TextEditingController(text: widget.entryToEdit?.serviceName ?? '');
    _userController = TextEditingController(text: widget.entryToEdit?.username ?? '');
    _passwordController = TextEditingController(text: widget.entryToEdit?.password ?? '');
  }

  @override
  void dispose() {
    _serviceController.dispose();
    _userController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _saveEntry() {
    if (_formKey.currentState!.validate()) {
      final notifier = ref.read(passwordListProvider.notifier);
      final now = DateTime.now();

      if (widget.entryToEdit == null) {
        final newEntry = PasswordEntry(
          id: PasswordGenerator.generateUniqueId(),
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
          createdAt: now,
        );
        notifier.addEntry(newEntry);
      } else {
        final updatedEntry = widget.entryToEdit!.copyWith(
          serviceName: _serviceController.text,
          username: _userController.text,
          password: _passwordController.text,
        );
        notifier.updateEntry(updatedEntry);
      }
      
      Navigator.of(context).pop();
    }
  }

  void _copyPassword() {
    final password = _passwordController.text;
    if (password.isNotEmpty) {
      Clipboard.setData(ClipboardData(text: password));

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('パスワードをクリップボードにコピーしました')),
      );
    }
  }

  void _deleteEntry() {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('削除の確認'),
        content: const Text('本当にこのエントリを削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('キャンセル'),
          ),
          TextButton(
            onPressed: () {
              if (widget.entryToEdit != null) {
                ref.read(passwordListProvider.notifier).deleteEntry(
                  widget.entryToEdit!.id,
                );
              }
              Navigator.of(ctx).pop(); 
              Navigator.of(context).pop(); 
            },
            child: const Text('削除', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.entryToEdit != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(isEditing ? 'パスワード編集' : '新規パスワード作成'),
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              TextFormField(
                controller: _serviceController,
                decoration: const InputDecoration(labelText: 'サービス/ウェブサイト名'),
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              TextFormField(
                controller: _userController,
                decoration: const InputDecoration(labelText: 'ユーザー名/メールアドレス'),
              ),
              TextFormField(
                controller: _passwordController,
                obscureText: true,
                decoration: InputDecoration(
                  labelText: 'パスワード',
                  suffixIcon: IconButton(
                    icon: const Icon(Icons.copy),
                    onPressed: _copyPassword,
                  ),
                ),
                validator: (value) => value!.isEmpty ? '必須項目です' : null,
              ),
              const SizedBox(height: 20),
              
              ElevatedButton(
                onPressed: _saveEntry,
                child: Text(isEditing ? '更新' : '保存'),
              ),
              
              if (isEditing) 
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    onPressed: _deleteEntry,
                    icon: const Icon(Icons.delete),
                    label: const Text('このパスワードを削除'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.red, 
                      foregroundColor: Colors.white,
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

----------------------------screens\generate_screen.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/password_provider.dart';
import '../models/password_entry.dart';
import '../services/generator.dart';
import 'edit_screen.dart';

class GenerateScreen extends ConsumerStatefulWidget {
	const GenerateScreen({super.key});

	@override
	ConsumerState<GenerateScreen> createState() => _GenerateScreenState();
}

class _GenerateScreenState extends ConsumerState<GenerateScreen> {
	int _length = 16;
	bool _useUpper = true;
	bool _useNumbers = true;
	bool _useSymbols = true;
	String _generatedPassword = '';

	void _generateAndAddPassword() {
		final generatedPass = PasswordGenerator.generatePassword(
			length: _length,
			useUpper: _useUpper,
			useNumbers: _useNumbers,
			useSymbols: _useSymbols,
		);

		setState(() {
			_generatedPassword = generatedPass;
		});

		if (generatedPass.isNotEmpty && !generatedPass.startsWith('エラー')) {
			final newEntry = PasswordEntry(
				id: PasswordGenerator.generateUniqueId(),
				serviceName: '（未設定）自動生成',
				username: '',
				password: generatedPass,
				createdAt: DateTime.now(),
			);
			
			ref.read(passwordListProvider.notifier).addEntry(newEntry);
		}
	}

	@override
	Widget build(BuildContext context) {
		final passwordList = ref.watch(passwordListProvider);

		return Scaffold(
			appBar: AppBar(title: const Text('パスワード生成と一覧')),
			body: SingleChildScrollView(
				padding: const EdgeInsets.all(16.0),
				child: Column(
					crossAxisAlignment: CrossAxisAlignment.start,
					children: [
						const Text('生成設定', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
						Slider(
							value: _length.toDouble(),
							min: 8, max: 32, divisions: 24,
							label: _length.toString(),
							onChanged: (double value) => setState(() => _length = value.round()),
						),
						Text('長さ: $_length'),
						
						CheckboxListTile(title: const Text('大文字 (A-Z)'), value: _useUpper, onChanged: (val) => setState(() => _useUpper = val!)),
						CheckboxListTile(title: const Text('数字 (0-9)'), value: _useNumbers, onChanged: (val) => setState(() => _useNumbers = val!)),
						CheckboxListTile(title: const Text('記号 (!@#\$)'), value: _useSymbols, onChanged: (val) => setState(() => _useSymbols = val!)),

						ElevatedButton(
							onPressed: _generateAndAddPassword,
							child: const Text('パスワードを生成 & リストに追加'),
						),
						
						if (_generatedPassword.isNotEmpty) 
							Padding(
								padding: const EdgeInsets.only(top: 16.0),
								child: Text('生成されたパスワード: $_generatedPassword', style: const TextStyle(fontWeight: FontWeight.bold)),
							),
						
						const Divider(height: 32),
						
						const Text('保存済みパスワード', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
						
						ListView.builder(
							shrinkWrap: true,
							physics: const NeverScrollableScrollPhysics(),
							itemCount: passwordList.length,
							itemBuilder: (context, index) {
								final entry = passwordList[index];
								return ListTile(
									title: Text(entry.serviceName),
									subtitle: Text('ユーザー名: ${entry.username.isEmpty ? 'N/A' : entry.username} | パスワード: ******'), // パスワードは非表示
									trailing: IconButton(
										icon: const Icon(Icons.edit),
										onPressed: () {
											Navigator.of(context).push(
												MaterialPageRoute(
													builder: (context) => EditScreen(entryToEdit: entry),
												),
											);
										},
									),
								);
							},
						),
					],
				),
			),
			floatingActionButton: FloatingActionButton(
				onPressed: () {
					Navigator.of(context).push(
						MaterialPageRoute(
							builder: (context) => const EditScreen(entryToEdit: null),
						),
					);
				},
				child: const Icon(Icons.add),
			),
		);
	}
}

----------------------------screens\pin_screen.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/master_pin_provider.dart';

enum PinScreenMode { setup, authenticate }

class PinScreen extends ConsumerStatefulWidget {
  final PinScreenMode mode;

  const PinScreen({super.key, required this.mode});

  @override
  ConsumerState<PinScreen> createState() => _PinScreenState();
}

class _PinScreenState extends ConsumerState<PinScreen> {
  final _pinController = TextEditingController();
  String _message = '';

  @override
  void dispose() {
    _pinController.dispose();
    super.dispose();
  }

  void _processPin() async {
    final pin = _pinController.text;
    final notifier = ref.read(masterPinProvider.notifier);
    
    if (pin.length < 4) {
      setState(() {
        _message = 'PINは4桁以上である必要があります。';
      });
      return;
    }
    
    setState(() {
      _message = '';
    });

    if (widget.mode == PinScreenMode.setup) {
      await notifier.setPin(pin);
      
    } else {
      final success = notifier.authenticate(pin);
      if (!success) {
        setState(() {
          _message = 'PINが一致しません。';
        });
        _pinController.clear();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final title = widget.mode == PinScreenMode.setup ? 'マスターPINの設定' : 'マスターPINの入力';
    final helpText = widget.mode == PinScreenMode.setup 
                  ? '安全のために4桁以上のPINを設定してください。'
                  : 'アプリを続けるにはPINを入力してください。';
    final buttonText = widget.mode == PinScreenMode.setup ? 'PINを設定して開始' : '認証';

    return Scaffold(
      appBar: AppBar(
        title: Text(title),
        automaticallyImplyLeading: false,
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(32.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(helpText, textAlign: TextAlign.center),
              const SizedBox(height: 24),
              SizedBox(
                width: 200, 
                child: TextField(
                  controller: _pinController,
                  keyboardType: TextInputType.number,
                  obscureText: true,
                  textAlign: TextAlign.center,
                  maxLength: 6, 
                  decoration: InputDecoration(
                    labelText: 'PINコード',
                    errorText: _message.isEmpty ? null : _message,
                    border: const OutlineInputBorder(),
                    counterText: '',
                  ),
                  onSubmitted: (_) => _processPin(), 
                ),
              ),
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: _processPin,
                child: Text(buttonText),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

----------------------------services\generator.dart----------------------------

import 'dart:math';
import 'package:uuid/uuid.dart'; 

const uuid = Uuid();

class PasswordGenerator {
  static const _lower = 'abcdefghijklmnopqrstuvwxyz';
  static const _upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  static const _numbers = '0123456789';
  static const _symbols = '!@#\$%^&*()_+=-`~[]{}|;:,.<>?/'; 

  static String generatePassword({
    required int length,
    bool useUpper = true,
    bool useNumbers = true,
    bool useSymbols = true,
  }) {
    String charPool = _lower;
    if (useUpper) charPool += _upper;
    if (useNumbers) charPool += _numbers;
    if (useSymbols) charPool += _symbols;

    if (charPool.isEmpty || length <= 0) {
      return '';
    }

    final random = Random.secure();
    return List.generate(length, (index) {
      final randomIndex = random.nextInt(charPool.length);
      return charPool[randomIndex];
    }).join();
  }

  static String generateUniqueId() {
    return uuid.v4();
  }
}

----------------------------main.dart----------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'screens/generate_screen.dart'; 
import 'screens/pin_screen.dart'; 
import 'providers/master_pin_provider.dart'; 

void main() {
  runApp(const ProviderScope(child: MyApp())); 
}

class MyApp extends ConsumerWidget { 
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final pinState = ref.watch(masterPinProvider);
    
    if (pinState.isSetup == false && pinState.isAuthenticated == false) {
      return const MaterialApp(
        debugShowCheckedModeBanner: false,
        home: Scaffold(body: Center(child: CircularProgressIndicator())),
      );
    }

    Widget homeScreen;

    if (pinState.isSetup && !pinState.isAuthenticated) {
      homeScreen = const PinScreen(mode: PinScreenMode.authenticate);
    } else if (!pinState.isSetup) {
      homeScreen = const PinScreen(mode: PinScreenMode.setup);
    } else {
      homeScreen = const GenerateScreen(); 
    }

    return MaterialApp(
      title: 'Password Manager',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      debugShowCheckedModeBanner: false,
      
      home: homeScreen,
    );
  }
}

----------------------------pubspec.yaml----------------------------

name: flutter_application1
description: A new Flutter project for a password manager prototype.
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: '>=3.10.0 <4.0.0' 

dependencies:
  flutter:
    sdk: flutter
  
  flutter_riverpod: ^2.5.1
  shared_preferences: ^2.2.2
  pointycastle: ^3.0.3

  uuid: ^4.4.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0 

flutter:
  uses-material-design: true
